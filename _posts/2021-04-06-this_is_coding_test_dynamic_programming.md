---
title: "[이것이 취업을 위한 코딩 테스트다] 다이나믹 프로그래밍(Dynamic Programming)"
category: Algorithm Theory
use_math: true
---

## 1. 중복되는 연산을 줄이자

- 컴퓨터를 활용해도 해결하기 어려운 문제는 '최적의 해'를 구하기에 시공간이 많이 필요한 문제이다.
- 컴퓨터는 연산속도, 메모리 공간의 한계가 있어 연산속도와 메모리 공간을 최대한으로 활용할 수 있는 **효율적인 알고리즘을 작성**해야 한다.

#### 예 : 피보나치 수열(점화식)
- 점화식 : 인접한 항들 사이의 관계식
- 피보나치 수열의 점화식
    - $a_{n+2}\ =\ f(a_{n+1}, a_n)\ =\ a_{n+1} + a_n$
    - $a_n\ =\ a_{n-1} + a_{n-2}$
    -  $a_1 = 1,\ a_2 = 1$
- 피보나치 수를 구하는 과정
    - $f(1), f(2)$ 함수를 반복해서 호출
    - $f(1), f(2)$를 만났을 때는 호출을 정지(재귀함수 혹은 반복문 정지 조건)
- **동일한 함수가 반복적으로 호출**되므로 n이 커지면 커질수록 호출되는 수가 많아진다(시간복잡도 : $O(2^N)$).

```python
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x-1) + fibo(x-2)

print(fibo(4))
# 3
```

<br>

## 2. 다이나믹 프로그래밍(= 동적계획법)

- **큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 기법**
- 메모리 공간을 약간 더 사용하면, 연산속도를 비약적으로 증가시킬 수 있는 방법(이미 해결된 문제는 답을 저장)
- 방식은 2가지(Top-down, Bottom-up)이다.

### 사용 조건

- 큰 문제를 작은 문제로 나눌 수 있다.
- 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
    
<br>

### 1) Top-down(= Memoization)

- 큰 문제를 해결하기 위해 작은 문제를 호출하는 방식
- 메모이제이션(Memoization) 기법을 사용하여 해결하는 방식(시간복잡도 : $O(N)$)
  
#### 메모이제이션
- 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법
- 값을 저장하는 방법이므로 캐싱(Caching)이라고도 함
- 다이나믹 프로그래밍을 구현하는 방법 중 한 종류
- 재귀함수를 사용하여 구현
    - 재귀 함수를 사용하면 오버헤드가 발생할 수 있으므로, **반복문을 사용해야함(Bottom-up)**

<br>

#### 예 : 피보나치 수열(메모이제이션) 

- 피보나치 수열 확인

```python
d = [0] * 100

def fibo(x):
    # 종료 조건
    if x == 1 or x == 2:
        return 1

    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

print(fibo(99))
# 218922995834555169026
```

- 호출되는 함수 확인

```python
d = [0] * 100

def fibo(x):
    print('f(' + str(x) + ')', end= ' ')
    
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

fibo(6) 
# f(6) f(5) f(4) f(3) f(2) f(1) f(2) f(3) f(4)
```

<br>

### 2) Bottom-up 반복문을 사용하여 해결
- 반복문을 사용한 방법, 다이나믹 프로그래밍의 전형적인 형태
- **다이나믹 프로그래밍은 반복문을 이용하면 성능이 더 좋음**

```python
# DP 테이블 초기화 
d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1):
    d[i] = d[i-1] + d[i-2]

print(d[n])
# 218922995834555169026
```

<br>

## 3. 실전 문제

> 1로 만들기